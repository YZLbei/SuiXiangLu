# 回溯

**回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」**

## 时间复杂度

回溯算法，求时间复杂度看成二叉树的遍历问题；

时间复杂度很多为O(2^n)



## 模板

```java
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

for中是选择的列表



## 动态规划和回溯

动态规划之所以比回溯快，是因为消除了重叠子问题



## ==剪枝==

### 发现重叠子问题

抽象出递归框架，出现状态相同的递归函数，说明存在重复，可以进行剪枝

### 剪枝

动态规划和回溯很像是父子关系，回溯的剪枝就是用dp的memo技巧

用memo的技巧剪枝，memo中存放的是状态

将回溯问题改成剪枝的情况，**要注意改变返回值**

注意basecase



#### 技巧

对于多个状态的情况，把多个状态变成字符串存入map中



## 回溯和DFS

**回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」**



## 回溯的原理

![img](https://labuladong.github.io/algo/images/backtracking/2.jpg)



回溯相当于在树上选择，选择的是树枝，图中就是选择1或者3

回溯的过程相当于在**前序和后序**进行操作